<!DOCTYPE html>
<html lang="ja">
<head>

  <meta charset="utf-8" />

  
  <title>CouchDB Source Code Reading part11</title>

  
  





  
  <meta name="author" content="Masayuki Takahashi" />
  <meta name="description" content="remainging code of couch_db:update_docs/4 前回まででcouch_db:doc_flush_atts/2の一連の処理を読み終えました。久々にcouch_db:update_do" />

  
  
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@masayuki" />
    <meta name="twitter:title" content="CouchDB Source Code Reading part11" />
    <meta name="twitter:description" content="remainging code of couch_db:update_docs/4 前回まででcouch_db:doc_flush_atts/2の一連の処理を読み終えました。久々にcouch_db:update_do" />
    <meta name="twitter:image" content="/img/avatar.jpg" />
  

  
  <meta property="og:type" content="article" />
  <meta property="og:title" content="CouchDB Source Code Reading part11" />
  <meta property="og:description" content="remainging code of couch_db:update_docs/4 前回まででcouch_db:doc_flush_atts/2の一連の処理を読み終えました。久々にcouch_db:update_do" />
  <meta property="og:url" content="/blog/2014/08/17/couchdb-code-reading11/" />
  <meta property="og:image" content="/img/avatar.jpg" />




<meta name="generator" content="Hugo 0.32" />


<link rel="canonical" href="/blog/2014/08/17/couchdb-code-reading11/" />
<link rel="alternative" href="/index.xml" title="act-act" type="application/atom+xml" />


<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />


<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />







<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="act-act" />
<meta name="msapplication-tooltip" content="act-act" />
<meta name='msapplication-navbutton-color' content="#5fbf5e" />
<meta name="msapplication-TileColor" content="#5fbf5e" />
<meta name="msapplication-TileImage" content="/img/tile-image-windows.png" />
<link rel="icon" href="/img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png" />
<link rel="icon" sizes="192x192" href="/img/touch-icon-android.png" />
<link rel="apple-touch-icon" href="/img/touch-icon-apple.png" />
<link rel="mask-icon" href="/img/safari-pinned-tab.svg" color="#5fbf5e" />



<link rel="stylesheet" href="//cdn.bootcss.com/video.js/6.2.8/alt/video-js-cdn.min.css" />

<link rel="stylesheet" href="/css/bundle.css" />
<link rel="stylesheet" href="/css/chroma-styles.css" />

  
  <!--[if lt IE 9]>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <script src="//cdn.bootcss.com/video.js/6.2.8/ie8/videojs-ie8.min.js"></script>
  <![endif]-->

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
  <![endif]-->


<script src="//cdn.bootcss.com/object-fit-images/3.2.3/ofi.min.js"></script>


<script src="//cdn.bootcss.com/smooth-scroll/12.1.4/js/smooth-scroll.polyfills.min.js"></script>


</head>
  <body>
    
    <div class="suspension">
      <a title="Go to top" class="to-top is-hide"><span class="icon icon-up"></span></a>
      
        
      
    </div>
    
    
  <header class="site-header">

<nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list">

      
      <li class="social-item">
        <a href="mailto:masayuki038@gmail.com" title="Email"><span class="icon icon-email"></span></a>
      </li>

      
      <li class="social-item">
        <a href="//github.com/masayuki038" title="GitHub"><span class="icon icon-github"></span></a>
      </li>

      <li class="social-item">
        <a href="//twitter.com/masayuki" title="Twitter"><span class="icon icon-twitter"></span></a>
      </li>

      <li class="social-item">
        <a href="//www.facebook.com/masayuki038" title="Facebook"><span class="icon icon-facebook"></span></a>
      </li>

      

      

      

      

      

      

      

      

      

      

      

      

      

      <li class="social-item">
        <a href="//www.linkedin.com/in/masayuki038" title="Linkedin"><span class="icon icon-linkedin"></span></a>
      </li>

      

      

      

      <li class="social-item">
        <a href="/index.xml"><span class="icon icon-rss" title="RSS"></span></a>
      </li>

    </ul>
  </nav>
  <button class="menu-toggle" type="button">
    <span class="icon icon-menu"></span>
  </button>
  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
            
            
            
              is-active
            ">
            <a href="/">Home</a>
          </li>
      
    </ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">CouchDB Source Code Reading part11</h1>
      <p class="post-meta">@Masayuki Takahashi · Aug 17, 2014 · 19 min read</p>
    </header>
    <article class="post-content">

<h2 id="remainging-code-of-couch-db-update-docs-4">remainging code of couch_db:update_docs/4</h2>

<p>前回までで<code>couch_db:doc_flush_atts/2</code>の一連の処理を読み終えました。久々に<code>couch_db:update_docs/4</code>に戻り、続きを見ていきます。</p>

<p>couch_db.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>update_docs<span class="o">(</span>Db, Docs, Options, interactive_edit<span class="o">)</span> -&gt;
<span class="ln"> 2</span>...
<span class="ln"> 3</span>        <span class="nv">DocBuckets3</span> <span class="o">=</span> <span class="o">[[</span>
<span class="ln"> 4</span>                <span class="o">{</span>doc_flush_atts<span class="o">(</span>set_new_att_revpos<span class="o">(</span>
<span class="ln"> 5</span>                        check_dup_atts<span class="o">(</span>Doc<span class="o">))</span>, Db#db.updater_fd<span class="o">)</span>, Ref<span class="o">}</span>
<span class="ln"> 6</span>                <span class="o">||</span> <span class="o">{</span>Doc, Ref<span class="o">}</span> &lt;- B<span class="o">]</span> <span class="o">||</span> B &lt;- DocBuckets2<span class="o">]</span>,
<span class="ln"> 7</span>        <span class="o">{</span>DocBuckets4, IdRevs<span class="o">}</span> <span class="o">=</span> new_revs<span class="o">(</span>DocBuckets3, <span class="o">[]</span>, <span class="o">[])</span>,
<span class="ln"> 8</span>
<span class="ln"> 9</span>        <span class="o">{</span>ok, CommitResults<span class="o">}</span> <span class="o">=</span> write_and_commit<span class="o">(</span>Db, DocBuckets4, NonRepDocs, Options2<span class="o">)</span>,
<span class="ln">10</span>
<span class="ln">11</span>        <span class="nv">ResultsDict</span> <span class="o">=</span> dict:from_list<span class="o">(</span>IdRevs ++ CommitResults ++ PreCommitFailures<span class="o">)</span>,
<span class="ln">12</span>        <span class="o">{</span>ok, lists:map<span class="o">(</span>
<span class="ln">13</span>            fun<span class="o">({</span><span class="c1">#doc{}, Ref}) -&gt;
</span><span class="ln">14</span><span class="c1"></span>                <span class="o">{</span>ok, Result<span class="o">}</span> <span class="o">=</span> dict:find<span class="o">(</span>Ref, ResultsDict<span class="o">)</span>,
<span class="ln">15</span>                Result
<span class="ln">16</span>            end, Docs2<span class="o">)}</span>
<span class="ln">17</span>    end.</code></pre></div></p>

<p><code>DockBucket3</code>はアタッチメント情報をディスクに書き込み、そのポインタを持った<code>Doc</code>によって構成されています。<code>DocBucket3</code>の構成は<code>couch_db:goup_alike_docs/1</code>のコメントに記載されています。具体的には以下の矢印右の構造になります。</p>

<p>couch_db.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln">1</span>% <span class="o">([</span>DocA, DocA, DocB, DocC<span class="o">]</span>, <span class="o">[])</span> -&gt; <span class="o">[[</span>DocA, DocA<span class="o">]</span>, <span class="o">[</span>DocB<span class="o">]</span>, <span class="o">[</span>DocC<span class="o">]]</span></code></pre></div></p>

<p>これを第一引数に取っている<code>couch_db:new_revs/3</code>を見ていきます。</p>

<p>couch_db.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>new_revs<span class="o">([]</span>, OutBuckets, IdRevsAcc<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    <span class="o">{</span>lists:reverse<span class="o">(</span>OutBuckets<span class="o">)</span>, IdRevsAcc<span class="o">}</span><span class="p">;</span>
<span class="ln"> 3</span>new_revs<span class="o">([</span>Bucket<span class="p">|</span>RestBuckets<span class="o">]</span>, OutBuckets, IdRevsAcc<span class="o">)</span> -&gt;
<span class="ln"> 4</span>    <span class="o">{</span>NewBucket, IdRevsAcc3<span class="o">}</span> <span class="o">=</span> lists:mapfoldl<span class="o">(</span>
<span class="ln"> 5</span>        fun<span class="o">({</span><span class="c1">#doc{revs={Start, RevIds}}=Doc, Ref}, IdRevsAcc2)-&gt;
</span><span class="ln"> 6</span><span class="c1"></span>        <span class="nv">NewRevId</span> <span class="o">=</span> new_revid<span class="o">(</span>Doc<span class="o">)</span>,
<span class="ln"> 7</span>        <span class="o">{{</span>Doc#doc<span class="o">{</span><span class="nv">revs</span><span class="o">={</span>Start+1, <span class="o">[</span>NewRevId <span class="p">|</span> RevIds<span class="o">]}}</span>, Ref<span class="o">}</span>,
<span class="ln"> 8</span>            <span class="o">[{</span>Ref, <span class="o">{</span>ok, <span class="o">{</span>Start+1, NewRevId<span class="o">}}}</span> <span class="p">|</span> IdRevsAcc2<span class="o">]}</span>
<span class="ln"> 9</span>    end, IdRevsAcc, Bucket<span class="o">)</span>,
<span class="ln">10</span>    new_revs<span class="o">(</span>RestBuckets, <span class="o">[</span>NewBucket<span class="p">|</span>OutBuckets<span class="o">]</span>, IdRevsAcc3<span class="o">)</span>.</code></pre></div></p>

<p><code>lists:mapfoldl/3</code>は<code>lists:map/2</code>と<code>lists:foldl/3</code>を組み合わせた関数で、1回のリスト走査で<code>map</code>と<code>foldl</code>を実行します。</p>

<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln">1</span>Eshell V5.10.3  <span class="o">(</span>abort with ^G<span class="o">)</span>
<span class="ln">2</span><span class="m">1</span>&gt; lists:mapfoldl<span class="o">(</span>fun<span class="o">(</span>X, Sum<span class="o">)</span> -&gt; <span class="o">{</span>X*2, X*2+Sum<span class="o">}</span> end, <span class="m">0</span>, <span class="o">[</span><span class="m">1</span>,2,3,4,5<span class="o">])</span>.
<span class="ln">3</span><span class="o">{[</span><span class="m">2</span>,4,6,8,10<span class="o">]</span>,30<span class="o">}</span></code></pre></div>

<p><code>Bucket</code>リストを指定して<code>lists:mapfoldl/3</code>します。<code>couch_db:new_revid/1</code>で新しい<code>RevId</code>を生成し、<code>#doc.revs</code>の<code>RevsId</code>に追加しています。<code>Start</code>に1を加えているのが良く分からない…。この値はTreの階層を表すと思っていたのですが、違うのかな。mapの方には新しく生成した<code>#doc</code>を、foldlの方には<code>{Ref, {ok, {Start+1, NewRevId}}}</code>を加えます。最終的に、呼び出し元に対して、新しいリビジョンを追加したドキュメント群を<code>DockBuckets4</code>、新しく生成した<code>RevId</code>の情報を<code>IdRevs</code>として返します。</p>

<h2 id="couch-db-write-and-commit-4">couch_db:write_and_commit/4</h2>

<p>次に<code>couch_db:write_and_commit/4</code>を見てみます。</p>

<p>couch_db.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>write_and_commit<span class="o">(</span><span class="c1">#db{update_pid=UpdatePid}=Db, DocBuckets1,
</span><span class="ln"> 2</span><span class="c1"></span>        NonRepDocs, Options0<span class="o">)</span> -&gt;
<span class="ln"> 3</span>    <span class="nv">DocBuckets</span> <span class="o">=</span> prepare_doc_summaries<span class="o">(</span>Db, DocBuckets1<span class="o">)</span>,
<span class="ln"> 4</span>    <span class="nv">Options</span> <span class="o">=</span> set_commit_option<span class="o">(</span>Options0<span class="o">)</span>,
<span class="ln"> 5</span>    <span class="nv">MergeConflicts</span> <span class="o">=</span> lists:member<span class="o">(</span>merge_conflicts, Options<span class="o">)</span>,
<span class="ln"> 6</span>    <span class="nv">FullCommit</span> <span class="o">=</span> lists:member<span class="o">(</span>full_commit, Options<span class="o">)</span>,
<span class="ln"> 7</span>    <span class="nv">MRef</span> <span class="o">=</span> erlang:monitor<span class="o">(</span>process, UpdatePid<span class="o">)</span>,
<span class="ln"> 8</span>    try
<span class="ln"> 9</span>        UpdatePid ! <span class="o">{</span>update_docs, self<span class="o">()</span>, DocBuckets, NonRepDocs, MergeConflicts, FullCommit<span class="o">}</span>,
<span class="ln">10</span>        <span class="k">case</span> collect_results<span class="o">(</span>UpdatePid, MRef, <span class="o">[])</span> of
<span class="ln">11</span>        <span class="o">{</span>ok, Results<span class="o">}</span> -&gt; <span class="o">{</span>ok, Results<span class="o">}</span><span class="p">;</span>
<span class="ln">12</span>        retry -&gt;
<span class="ln">13</span>            % This can happen <span class="k">if</span> the db file we wrote to was swapped out by
<span class="ln">14</span>            % compaction. Retry by reopening the db and writing to the current file
<span class="ln">15</span>            <span class="o">{</span>ok, Db2<span class="o">}</span> <span class="o">=</span> open_ref_counted<span class="o">(</span>Db#db.main_pid, self<span class="o">())</span>,
<span class="ln">16</span>            <span class="nv">DocBuckets2</span> <span class="o">=</span> <span class="o">[</span>
<span class="ln">17</span>                <span class="o">[{</span>doc_flush_atts<span class="o">(</span>Doc, Db2#db.updater_fd<span class="o">)</span>, Ref<span class="o">}</span> <span class="o">||</span> <span class="o">{</span>Doc, Ref<span class="o">}</span> &lt;- Bucket<span class="o">]</span> <span class="o">||</span>
<span class="ln">18</span>                Bucket &lt;- DocBuckets1
<span class="ln">19</span>            <span class="o">]</span>,
<span class="ln">20</span>            % We only retry once
<span class="ln">21</span>            <span class="nv">DocBuckets3</span> <span class="o">=</span> prepare_doc_summaries<span class="o">(</span>Db2, DocBuckets2<span class="o">)</span>,
<span class="ln">22</span>            close<span class="o">(</span>Db2<span class="o">)</span>,
<span class="ln">23</span>            UpdatePid ! <span class="o">{</span>update_docs, self<span class="o">()</span>, DocBuckets3, NonRepDocs, MergeConflicts, FullCommit<span class="o">}</span>,
<span class="ln">24</span>            <span class="k">case</span> collect_results<span class="o">(</span>UpdatePid, MRef, <span class="o">[])</span> of
<span class="ln">25</span>            <span class="o">{</span>ok, Results<span class="o">}</span> -&gt; <span class="o">{</span>ok, Results<span class="o">}</span><span class="p">;</span>
<span class="ln">26</span>            retry -&gt; throw<span class="o">({</span>update_error, compaction_retry<span class="o">})</span>
<span class="ln">27</span>            end
<span class="ln">28</span>        end
<span class="ln">29</span>    after
<span class="ln">30</span>        erlang:demonitor<span class="o">(</span>MRef, <span class="o">[</span>flush<span class="o">])</span>
<span class="ln">31</span>    end.</code></pre></div></p>

<p>そのまま<code>couch_db:prepare_doc_summaries/2</code>を見てみます。</p>

<p>couch_db.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>prepare_doc_summaries<span class="o">(</span>Db, BucketList<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    <span class="o">[</span>lists:map<span class="o">(</span>
<span class="ln"> 3</span>        fun<span class="o">({</span><span class="c1">#doc{body = Body, atts = Atts} = Doc, Ref}) -&gt;
</span><span class="ln"> 4</span><span class="c1"></span>            <span class="nv">DiskAtts</span> <span class="o">=</span> <span class="o">[{</span>N, T, P, AL, DL, R, M, E<span class="o">}</span> <span class="o">||</span>
<span class="ln"> 5</span>                <span class="c1">#att{name = N, type = T, data = {_, P}, md5 = M, revpos = R,
</span><span class="ln"> 6</span><span class="c1"></span>                    <span class="nv">att_len</span> <span class="o">=</span> AL, <span class="nv">disk_len</span> <span class="o">=</span> DL, <span class="nv">encoding</span> <span class="o">=</span> E<span class="o">}</span> &lt;- Atts<span class="o">]</span>,
<span class="ln"> 7</span>            <span class="nv">AttsFd</span> <span class="o">=</span> <span class="k">case</span> Atts of
<span class="ln"> 8</span>            <span class="o">[</span><span class="c1">#att{data = {Fd, _}} | _] -&gt;
</span><span class="ln"> 9</span><span class="c1"></span>                Fd<span class="p">;</span>
<span class="ln">10</span>            <span class="o">[]</span> -&gt;
<span class="ln">11</span>                nil
<span class="ln">12</span>            end,
<span class="ln">13</span>            <span class="nv">SummaryChunk</span> <span class="o">=</span> couch_db_updater:make_doc_summary<span class="o">(</span>Db, <span class="o">{</span>Body, DiskAtts<span class="o">})</span>,
<span class="ln">14</span>            <span class="o">{</span>Doc#doc<span class="o">{</span><span class="nv">body</span> <span class="o">=</span> <span class="o">{</span>summary, SummaryChunk, AttsFd<span class="o">}}</span>, Ref<span class="o">}</span>
<span class="ln">15</span>        end,
<span class="ln">16</span>        Bucket<span class="o">)</span> <span class="o">||</span> Bucket &lt;- BucketList<span class="o">]</span>.</code></pre></div></p>

<p><code>#doc.atts</code>をディスクに書き込む為に変換し、また<code>#doc.atts</code>から<code>Fd</code>を取り出しています。ディスクに書き込む為に変換した<code>DiskAtts</code>と<code>#doc.body</code>を指定し、<code>couch_db_updater:make_doc_summary/2</code>を呼び出しています。この関数を見てみます。</p>

<p>couch_db.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>make_doc_summary<span class="o">(</span><span class="c1">#db{compression = Comp}, {Body0, Atts0}) -&gt;
</span><span class="ln"> 2</span><span class="c1"></span>    <span class="nv">Body</span> <span class="o">=</span> <span class="k">case</span> couch_compress:is_compressed<span class="o">(</span>Body0, Comp<span class="o">)</span> of
<span class="ln"> 3</span>    <span class="nb">true</span> -&gt;
<span class="ln"> 4</span>        Body0<span class="p">;</span>
<span class="ln"> 5</span>    <span class="nb">false</span> -&gt;
<span class="ln"> 6</span>        % pre <span class="m">1</span>.2 database file format
<span class="ln"> 7</span>        couch_compress:compress<span class="o">(</span>Body0, Comp<span class="o">)</span>
<span class="ln"> 8</span>    end,
<span class="ln"> 9</span>    <span class="nv">Atts</span> <span class="o">=</span> <span class="k">case</span> couch_compress:is_compressed<span class="o">(</span>Atts0, Comp<span class="o">)</span> of
<span class="ln">10</span>    <span class="nb">true</span> -&gt;
<span class="ln">11</span>        Atts0<span class="p">;</span>
<span class="ln">12</span>    <span class="nb">false</span> -&gt;
<span class="ln">13</span>        couch_compress:compress<span class="o">(</span>Atts0, Comp<span class="o">)</span>
<span class="ln">14</span>    end,
<span class="ln">15</span>    <span class="nv">SummaryBin</span> <span class="o">=</span> ?term_to_bin<span class="o">({</span>Body, Atts<span class="o">})</span>,
<span class="ln">16</span>    couch_file:assemble_file_chunk<span class="o">(</span>SummaryBin, couch_util:md5<span class="o">(</span>SummaryBin<span class="o">))</span>.</code></pre></div></p>

<p>引数で渡された<code>{Body0, Atts0}</code>をそれぞれcompressしてバイナリに変換しているようです。続けて<code>couch_file:assemble_file_chunk/2</code>を見てみます。</p>

<p>couch_file.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln">1</span>assemble_file_chunk<span class="o">(</span>Bin<span class="o">)</span> -&gt;
<span class="ln">2</span>    <span class="o">[</span>&lt;&lt;<span class="m">0</span>:1/integer, <span class="o">(</span>iolist_size<span class="o">(</span>Bin<span class="o">))</span>:31/integer&gt;&gt;, Bin<span class="o">]</span>.
<span class="ln">3</span>
<span class="ln">4</span>assemble_file_chunk<span class="o">(</span>Bin, Md5<span class="o">)</span> -&gt;
<span class="ln">5</span>    <span class="o">[</span><span class="s">&lt;&lt;1:1</span>/integer, <span class="o">(</span>iolist_size<span class="o">(</span>Bin<span class="o">))</span>:31/integer&gt;&gt;, Md5, Bin<span class="o">]</span>.</code></pre></div></p>

<p><a href="http://masayuki038.github.io/blog/2014/08/03/couchdb-code-reading10/#data-block">前回書いた</a>ように、データブロックに書き出す為にヘッダを付けてます。</p>

<p><code>couch_db:write_and_commit/4</code>の冒頭に戻り、<code>couch_db:prepare_doc_summaries/2</code>の呼び出しにより<code>DocBucket</code>に格納された<code>#doc</code>の<code>body</code>は<code>{summary, SummaryChunk, AttsFd}</code>になっています。前記のデータブロックにかい出す為のヘッダを付けたバイナリは<code>SummaryChunk</code>にバインドされています。</p>

<p><code>MergeConflicts</code>と<code>FullCommit</code>を設定し、下記の<code>couch_db_updater:handle_info/2</code>が呼び出されます。</p>

<p>couch_db_updater.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>handle_info<span class="o">({</span>update_docs, Client, GroupedDocs, NonRepDocs, MergeConflicts,
<span class="ln"> 2</span>        FullCommit<span class="o">}</span>, Db<span class="o">)</span> -&gt;
<span class="ln"> 3</span>    <span class="nv">GroupedDocs2</span> <span class="o">=</span> <span class="o">[[{</span>Client, D<span class="o">}</span> <span class="o">||</span> D &lt;- DocGroup<span class="o">]</span> <span class="o">||</span> DocGroup &lt;- GroupedDocs<span class="o">]</span>,
<span class="ln"> 4</span>    <span class="k">if</span> <span class="nv">NonRepDocs</span> <span class="o">==</span> <span class="o">[]</span> -&gt;
<span class="ln"> 5</span>        <span class="o">{</span>GroupedDocs3, Clients, FullCommit2<span class="o">}</span> <span class="o">=</span> collect_updates<span class="o">(</span>GroupedDocs2,
<span class="ln"> 6</span>                <span class="o">[</span>Client<span class="o">]</span>, MergeConflicts, FullCommit<span class="o">)</span><span class="p">;</span>
<span class="ln"> 7</span>    <span class="nb">true</span> -&gt;
<span class="ln"> 8</span>        <span class="nv">GroupedDocs3</span> <span class="o">=</span> GroupedDocs2,
<span class="ln"> 9</span>        <span class="nv">FullCommit2</span> <span class="o">=</span> FullCommit,
<span class="ln">10</span>        <span class="nv">Clients</span> <span class="o">=</span> <span class="o">[</span>Client<span class="o">]</span>
<span class="ln">11</span>    end,
<span class="ln">12</span>    <span class="nv">NonRepDocs2</span> <span class="o">=</span> <span class="o">[{</span>Client, NRDoc<span class="o">}</span> <span class="o">||</span> NRDoc &lt;- NonRepDocs<span class="o">]</span>,
<span class="ln">13</span>    try update_docs_int<span class="o">(</span>Db, GroupedDocs3, NonRepDocs2, MergeConflicts,
<span class="ln">14</span>                FullCommit2<span class="o">)</span> of
<span class="ln">15</span>    <span class="o">{</span>ok, Db2, UpdatedDDocIds<span class="o">}</span> -&gt;
<span class="ln">16</span>        <span class="nv">ok</span> <span class="o">=</span> gen_server:call<span class="o">(</span>Db#db.main_pid, <span class="o">{</span>db_updated, Db2<span class="o">})</span>,
<span class="ln">17</span>        <span class="k">if</span> Db2#db.update_seq /<span class="o">=</span> Db#db.update_seq -&gt;
<span class="ln">18</span>            couch_db_update_notifier:notify<span class="o">({</span>updated, Db2#db.name<span class="o">})</span><span class="p">;</span>
<span class="ln">19</span>        <span class="nb">true</span> -&gt; ok
<span class="ln">20</span>        end,
<span class="ln">21</span>        <span class="o">[</span>catch<span class="o">(</span>ClientPid ! <span class="o">{</span><span class="k">done</span>, self<span class="o">()})</span> <span class="o">||</span> ClientPid &lt;- Clients<span class="o">]</span>,
<span class="ln">22</span>        lists:foreach<span class="o">(</span>fun<span class="o">(</span>DDocId<span class="o">)</span> -&gt;
<span class="ln">23</span>            couch_db_update_notifier:notify<span class="o">({</span>ddoc_updated, <span class="o">{</span>Db#db.name, DDocId<span class="o">}})</span>
<span class="ln">24</span>        end, UpdatedDDocIds<span class="o">)</span>,
<span class="ln">25</span>        <span class="o">{</span>noreply, Db2<span class="o">}</span>
<span class="ln">26</span>    catch
<span class="ln">27</span>        throw: retry -&gt;
<span class="ln">28</span>            <span class="o">[</span>catch<span class="o">(</span>ClientPid ! <span class="o">{</span>retry, self<span class="o">()})</span> <span class="o">||</span> ClientPid &lt;- Clients<span class="o">]</span>,
<span class="ln">29</span>            <span class="o">{</span>noreply, Db<span class="o">}</span>
<span class="ln">30</span>    end<span class="p">;</span></code></pre></div></p>

<p><code>GroupDocs</code>→<code>GroupDcos2</code>、<code>NonRepDocs</code>→<code>NonRepDocs2</code>への変換後、<code>couch_db_updater:update_docs_int/5</code>を呼び出していま。</p>

<h2 id="couch-db-updater-update-docs-int-5">couch_db_updater:update_docs_int/5</h2>

<p><code>couch_db_updater:update_docs_int/5</code>を見てみます。</p>

<p>couch_db_updater.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>update_docs_int<span class="o">(</span>Db, DocsList, NonRepDocs, MergeConflicts, FullCommit<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    <span class="c1">#db{
</span><span class="ln"> 3</span><span class="c1"></span>        <span class="nv">fulldocinfo_by_id_btree</span> <span class="o">=</span> DocInfoByIdBTree,
<span class="ln"> 4</span>        <span class="nv">docinfo_by_seq_btree</span> <span class="o">=</span> DocInfoBySeqBTree,
<span class="ln"> 5</span>        <span class="nv">update_seq</span> <span class="o">=</span> LastSeq,
<span class="ln"> 6</span>        <span class="nv">revs_limit</span> <span class="o">=</span> RevsLimit
<span class="ln"> 7</span>        <span class="o">}</span> <span class="o">=</span> Db,
<span class="ln"> 8</span>    <span class="nv">Ids</span> <span class="o">=</span> <span class="o">[</span>Id <span class="o">||</span> <span class="o">[{</span>_Client, <span class="o">{</span><span class="c1">#doc{id=Id}, _Ref}}|_] &lt;- DocsList],
</span><span class="ln"> 9</span><span class="c1"></span>    % lookup up the old documents, <span class="k">if</span> they exist.
<span class="ln">10</span>    <span class="nv">OldDocLookups</span> <span class="o">=</span> couch_btree:lookup<span class="o">(</span>DocInfoByIdBTree, Ids<span class="o">)</span>,
<span class="ln">11</span>    <span class="nv">OldDocInfos</span> <span class="o">=</span> lists:zipwith<span class="o">(</span>
<span class="ln">12</span>        fun<span class="o">(</span>_Id, <span class="o">{</span>ok, FullDocInfo<span class="o">})</span> -&gt;
<span class="ln">13</span>            FullDocInfo<span class="p">;</span>
<span class="ln">14</span>        <span class="o">(</span>Id, not_found<span class="o">)</span> -&gt;
<span class="ln">15</span>            <span class="c1">#full_doc_info{id=Id}
</span><span class="ln">16</span><span class="c1"></span>        end,
<span class="ln">17</span>        Ids, OldDocLookups<span class="o">)</span>,
<span class="ln">18</span>    % Merge the new docs into the revision trees.
<span class="ln">19</span>    <span class="o">{</span>ok, NewFullDocInfos, RemoveSeqs, NewSeq<span class="o">}</span> <span class="o">=</span> merge_rev_trees<span class="o">(</span>RevsLimit,
<span class="ln">20</span>            MergeConflicts, DocsList, OldDocInfos, <span class="o">[]</span>, <span class="o">[]</span>, LastSeq<span class="o">)</span>,
<span class="ln">21</span>
<span class="ln">22</span>    % All documents are now ready to write.
<span class="ln">23</span>
<span class="ln">24</span>    <span class="o">{</span>ok, Db2<span class="o">}</span>  <span class="o">=</span> update_local_docs<span class="o">(</span>Db, NonRepDocs<span class="o">)</span>,
<span class="ln">25</span>
<span class="ln">26</span>    % Write out the document summaries <span class="o">(</span>the bodies are stored in the nodes of
<span class="ln">27</span>    % the trees, the attachments are already written to disk<span class="o">)</span>
<span class="ln">28</span>    <span class="o">{</span>ok, FlushedFullDocInfos<span class="o">}</span> <span class="o">=</span> flush_trees<span class="o">(</span>Db2, NewFullDocInfos, <span class="o">[])</span>,
<span class="ln">29</span>
<span class="ln">30</span>    <span class="o">{</span>IndexFullDocInfos, IndexDocInfos, UpdatedDDocIds<span class="o">}</span> <span class="o">=</span>
<span class="ln">31</span>            new_index_entries<span class="o">(</span>FlushedFullDocInfos, <span class="o">[]</span>, <span class="o">[]</span>, <span class="o">[])</span>,
<span class="ln">32</span>
<span class="ln">33</span>    % and the indexes
<span class="ln">34</span>    <span class="o">{</span>ok, DocInfoByIdBTree2<span class="o">}</span> <span class="o">=</span> couch_btree:add_remove<span class="o">(</span>DocInfoByIdBTree, IndexFullDocInfos, <span class="o">[])</span>,
<span class="ln">35</span>    <span class="o">{</span>ok, DocInfoBySeqBTree2<span class="o">}</span> <span class="o">=</span> couch_btree:add_remove<span class="o">(</span>DocInfoBySeqBTree, IndexDocInfos, RemoveSeqs<span class="o">)</span>,
<span class="ln">36</span>
<span class="ln">37</span>    <span class="nv">Db3</span> <span class="o">=</span> Db2#db<span class="o">{</span>
<span class="ln">38</span>        <span class="nv">fulldocinfo_by_id_btree</span> <span class="o">=</span> DocInfoByIdBTree2,
<span class="ln">39</span>        <span class="nv">docinfo_by_seq_btree</span> <span class="o">=</span> DocInfoBySeqBTree2,
<span class="ln">40</span>        <span class="nv">update_seq</span> <span class="o">=</span> NewSeq<span class="o">}</span>,
<span class="ln">41</span>
<span class="ln">42</span>    % Check <span class="k">if</span> we just updated any design documents, and update the validation
<span class="ln">43</span>    % funs <span class="k">if</span> we did.
<span class="ln">44</span>    <span class="nv">Db4</span> <span class="o">=</span> <span class="k">case</span> UpdatedDDocIds of
<span class="ln">45</span>    <span class="o">[]</span> -&gt;
<span class="ln">46</span>        Db3<span class="p">;</span>
<span class="ln">47</span>    _ -&gt;
<span class="ln">48</span>        refresh_validate_doc_funs<span class="o">(</span>Db3<span class="o">)</span>
<span class="ln">49</span>    end,
<span class="ln">50</span>
<span class="ln">51</span>    <span class="o">{</span>ok, commit_data<span class="o">(</span>Db4, not FullCommit<span class="o">)</span>, UpdatedDDocIds<span class="o">}</span>.</code></pre></div></p>

<p>大分長いので大まかに見ていきます。更新対象の<code>DocList</code>から<code>Id</code>を取り出し、その<code>Id</code>を指定して<code>#db.fulldocinfo_by_id_btree</code>から<code>FullDocInfo</code>を取り出します。該当する<code>FullDocInfo</code>が無かった場合は<code>Id</code>だけ設定した空の<code>FullDocInfo</code>を生成し、<code>OldDocInfos</code>とします。更新対象の<code>DocList</code>と<code>OldDocInfos</code>を指定し、<code>couch_db_updater:merge_rev_trees/7</code>を呼び出します。</p>

<h2 id="couch-db-updater-merge-rev-trees-7">couch_db_updater:merge_rev_trees/7</h2>

<p><code>couch_db_updater:merge_rev_trees/7</code>を見て行きます。</p>

<p>couch_db_updater.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>merge_rev_trees<span class="o">(</span>_Limit, _Merge, <span class="o">[]</span>, <span class="o">[]</span>, AccNewInfos, AccRemoveSeqs, AccSeq<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    <span class="o">{</span>ok, lists:reverse<span class="o">(</span>AccNewInfos<span class="o">)</span>, AccRemoveSeqs, AccSeq<span class="o">}</span><span class="p">;</span>
<span class="ln"> 3</span>merge_rev_trees<span class="o">(</span>Limit, MergeConflicts, <span class="o">[</span>NewDocs<span class="p">|</span>RestDocsList<span class="o">]</span>,
<span class="ln"> 4</span>        <span class="o">[</span>OldDocInfo<span class="p">|</span>RestOldInfo<span class="o">]</span>, AccNewInfos, AccRemoveSeqs, AccSeq<span class="o">)</span> -&gt;
<span class="ln"> 5</span>    <span class="c1">#full_doc_info{id=Id,rev_tree=OldTree,deleted=OldDeleted0,update_seq=OldSeq}
</span><span class="ln"> 6</span><span class="c1"></span>            <span class="o">=</span> OldDocInfo,
<span class="ln"> 7</span>    <span class="o">{</span>NewRevTree, _<span class="o">}</span> <span class="o">=</span> lists:foldl<span class="o">(</span>
<span class="ln"> 8</span>        fun<span class="o">({</span>Client, <span class="o">{</span><span class="c1">#doc{revs={Pos,[_Rev|PrevRevs]}}=NewDoc, Ref}}, {AccTree, OldDeleted}) -&gt;
</span><span class="ln"> 9</span><span class="c1"></span>            <span class="k">if</span> not MergeConflicts -&gt;
<span class="ln">10</span>                <span class="k">case</span> couch_key_tree:merge<span class="o">(</span>AccTree, couch_doc:to_path<span class="o">(</span>NewDoc<span class="o">)</span>,
<span class="ln">11</span>                    Limit<span class="o">)</span> of
<span class="ln">12</span>                <span class="o">{</span>_NewTree, conflicts<span class="o">}</span> when <span class="o">(</span>not OldDeleted<span class="o">)</span> -&gt;
<span class="ln">13</span>                    send_result<span class="o">(</span>Client, Ref, conflict<span class="o">)</span>,
<span class="ln">14</span>                    <span class="o">{</span>AccTree, OldDeleted<span class="o">}</span><span class="p">;</span>
<span class="ln">15</span>                <span class="o">{</span>NewTree, conflicts<span class="o">}</span> when PrevRevs /<span class="o">=</span> <span class="o">[]</span> -&gt;
<span class="ln">16</span>                    % Check to be sure <span class="k">if</span> prev revision was specified, it<span class="s1">&#39;s
</span><span class="ln">17</span><span class="s1">                    % a leaf node in the tree
</span><span class="ln">18</span><span class="s1">                    Leafs = couch_key_tree:get_all_leafs(AccTree),
</span><span class="ln">19</span><span class="s1">                    IsPrevLeaf = lists:any(fun({_, {LeafPos, [LeafRevId|_]}}) -&gt;
</span><span class="ln">20</span><span class="s1">                            {LeafPos, LeafRevId} == {Pos-1, hd(PrevRevs)}
</span><span class="ln">21</span><span class="s1">                        end, Leafs),
</span><span class="ln">22</span><span class="s1">                    if IsPrevLeaf -&gt;
</span><span class="ln">23</span><span class="s1">                        {NewTree, OldDeleted};
</span><span class="ln">24</span><span class="s1">                    true -&gt;
</span><span class="ln">25</span><span class="s1">                        send_result(Client, Ref, conflict),
</span><span class="ln">26</span><span class="s1">                        {AccTree, OldDeleted}
</span><span class="ln">27</span><span class="s1">                    end;
</span><span class="ln">28</span><span class="s1">                {NewTree, no_conflicts} when  AccTree == NewTree -&gt;
</span><span class="ln">29</span><span class="s1">                    % the tree didn&#39;</span>t change at all
<span class="ln">30</span>                    % meaning we are saving a rev that<span class="err">&#39;</span>s already
<span class="ln">31</span>                    % been editted again.
<span class="ln">32</span>                    <span class="k">if</span> <span class="o">(</span><span class="nv">Pos</span> <span class="o">==</span> <span class="m">1</span><span class="o">)</span> and OldDeleted -&gt;
<span class="ln">33</span>                        % this means we are recreating a brand new document
<span class="ln">34</span>                        % into a state that already existed before.
<span class="ln">35</span>                        % put the rev into a subsequent edit of the deletion
<span class="ln">36</span>                        <span class="c1">#doc_info{revs=[#rev_info{rev={OldPos,OldRev}}|_]} =
</span><span class="ln">37</span><span class="c1"></span>                                couch_doc:to_doc_info<span class="o">(</span>OldDocInfo<span class="o">)</span>,
<span class="ln">38</span>                        <span class="nv">NewRevId</span> <span class="o">=</span> couch_db:new_revid<span class="o">(</span>
<span class="ln">39</span>                                NewDoc#doc<span class="o">{</span><span class="nv">revs</span><span class="o">={</span>OldPos, <span class="o">[</span>OldRev<span class="o">]}})</span>,
<span class="ln">40</span>                        <span class="nv">NewDoc2</span> <span class="o">=</span> NewDoc#doc<span class="o">{</span><span class="nv">revs</span><span class="o">={</span>OldPos + <span class="m">1</span>, <span class="o">[</span>NewRevId, OldRev<span class="o">]}}</span>,
<span class="ln">41</span>                        <span class="o">{</span>NewTree2, _<span class="o">}</span> <span class="o">=</span> couch_key_tree:merge<span class="o">(</span>AccTree,
<span class="ln">42</span>                                couch_doc:to_path<span class="o">(</span>NewDoc2<span class="o">)</span>, Limit<span class="o">)</span>,
<span class="ln">43</span>                        % we changed the rev id, this tells the <span class="nb">caller</span> we did
<span class="ln">44</span>                        send_result<span class="o">(</span>Client, Ref, <span class="o">{</span>ok, <span class="o">{</span>OldPos + <span class="m">1</span>, NewRevId<span class="o">}})</span>,
<span class="ln">45</span>                        <span class="o">{</span>NewTree2, OldDeleted<span class="o">}</span><span class="p">;</span>
<span class="ln">46</span>                    <span class="nb">true</span> -&gt;
<span class="ln">47</span>                        send_result<span class="o">(</span>Client, Ref, conflict<span class="o">)</span>,
<span class="ln">48</span>                        <span class="o">{</span>AccTree, OldDeleted<span class="o">}</span>
<span class="ln">49</span>                    end<span class="p">;</span>
<span class="ln">50</span>                <span class="o">{</span>NewTree, _<span class="o">}</span> -&gt;
<span class="ln">51</span>                    <span class="o">{</span>NewTree, NewDoc#doc.deleted<span class="o">}</span>
<span class="ln">52</span>                end<span class="p">;</span>
<span class="ln">53</span>            <span class="nb">true</span> -&gt;
<span class="ln">54</span>                <span class="o">{</span>NewTree, _<span class="o">}</span> <span class="o">=</span> couch_key_tree:merge<span class="o">(</span>AccTree,
<span class="ln">55</span>                            couch_doc:to_path<span class="o">(</span>NewDoc<span class="o">)</span>, Limit<span class="o">)</span>,
<span class="ln">56</span>                <span class="o">{</span>NewTree, OldDeleted<span class="o">}</span>
<span class="ln">57</span>            end
<span class="ln">58</span>        end,
<span class="ln">59</span>        <span class="o">{</span>OldTree, OldDeleted0<span class="o">}</span>, NewDocs<span class="o">)</span>,
<span class="ln">60</span>    <span class="k">if</span> <span class="nv">NewRevTree</span> <span class="o">==</span> OldTree -&gt;
<span class="ln">61</span>        % nothing changed
<span class="ln">62</span>        merge_rev_trees<span class="o">(</span>Limit, MergeConflicts, RestDocsList, RestOldInfo,
<span class="ln">63</span>            AccNewInfos, AccRemoveSeqs, AccSeq<span class="o">)</span><span class="p">;</span>
<span class="ln">64</span>    <span class="nb">true</span> -&gt;
<span class="ln">65</span>        % we have updated the document, give it a new seq <span class="c1">#
</span><span class="ln">66</span><span class="c1"></span>        <span class="nv">NewInfo</span> <span class="o">=</span> <span class="c1">#full_doc_info{id=Id,update_seq=AccSeq+1,rev_tree=NewRevTree},
</span><span class="ln">67</span><span class="c1"></span>        <span class="nv">RemoveSeqs</span> <span class="o">=</span> <span class="k">case</span> OldSeq of
<span class="ln">68</span>            <span class="m">0</span> -&gt; AccRemoveSeqs<span class="p">;</span>
<span class="ln">69</span>            _ -&gt; <span class="o">[</span>OldSeq <span class="p">|</span> AccRemoveSeqs<span class="o">]</span>
<span class="ln">70</span>        end,
<span class="ln">71</span>        merge_rev_trees<span class="o">(</span>Limit, MergeConflicts, RestDocsList, RestOldInfo,
<span class="ln">72</span>            <span class="o">[</span>NewInfo<span class="p">|</span>AccNewInfos<span class="o">]</span>, RemoveSeqs, AccSeq+1<span class="o">)</span>
<span class="ln">73</span>    end.</code></pre></div></p>

<p>更新対象のドキュメントと、それに対する<code>#full_doc_info</code>をマージする処理で、実際のマージは<code>couch_doc:merge/3</code>を呼び出すことによって実現しています。その関数を呼び出す前に<code>couch_doc:to_path/1</code>を呼び出しているので、先にこの関数を見てみます。</p>

<p>couch_doc.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>-spec to_path<span class="o">(</span><span class="c1">#doc{}) -&gt; path().
</span><span class="ln"> 2</span><span class="c1"></span>to_path<span class="o">(</span><span class="c1">#doc{revs={Start, RevIds}}=Doc) -&gt;
</span><span class="ln"> 3</span><span class="c1"></span>    <span class="o">[</span>Branch<span class="o">]</span> <span class="o">=</span> to_branch<span class="o">(</span>Doc, lists:reverse<span class="o">(</span>RevIds<span class="o">))</span>,
<span class="ln"> 4</span>    <span class="o">{</span>Start - length<span class="o">(</span>RevIds<span class="o">)</span> + <span class="m">1</span>, Branch<span class="o">}</span>.
<span class="ln"> 5</span>
<span class="ln"> 6</span>-spec to_branch<span class="o">(</span><span class="c1">#doc{}, [RevId::binary()]) -&gt; [branch()].
</span><span class="ln"> 7</span><span class="c1"></span>to_branch<span class="o">(</span>Doc, <span class="o">[</span>RevId<span class="o">])</span> -&gt;
<span class="ln"> 8</span>    <span class="o">[{</span>RevId, Doc, <span class="o">[]}]</span><span class="p">;</span>
<span class="ln"> 9</span>to_branch<span class="o">(</span>Doc, <span class="o">[</span>RevId <span class="p">|</span> Rest<span class="o">])</span> -&gt;
<span class="ln">10</span>    <span class="o">[{</span>RevId, ?REV_MISSING, to_branch<span class="o">(</span>Doc, Rest<span class="o">)}]</span>.</code></pre></div></p>

<p>上記関数を呼び出すと、<code>#doc</code>は以下のように変換されます。</p>

<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln">1</span><span class="o">{</span><span class="m">3</span>, <span class="o">{</span>RevId3, <span class="o">[]</span>, <span class="o">{</span>RevId2, <span class="o">[]</span>, <span class="o">{</span>RevId1, Doc, <span class="o">[]}}}}}</span>.</code></pre></div>

<p>また、<code>#full_doc_info.rev_tree</code>は以下のような構造になっています。</p>

<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln">1</span><span class="o">[{</span>Pos, <span class="o">{</span>Key, Value, SubTree<span class="o">}}</span>, <span class="o">{</span>Pos, <span class="o">{</span>Key, Value, SubTree<span class="o">}}</span>, ...<span class="o">}]</span></code></pre></div>

<p>上記より、<code>couch_doc:to_path/1</code>は<code>#full_doc_info.rev_tree</code>とマージできるように<code>#doc</code>を<code>{Key, Value, SubTree}</code>の形式に変換しているようです。</p>

<p>ここから<code>couch_doc:merge/3</code>→<code>couch_doc:merge_one/4</code>→<code>couch_doc:merge_at/3</code>→<code>couch_doc:merge_simp2</code>と続き、<code>rev_tree</code>のマージが行われますが、かなり長いので割愛します。更新の衝突がなければ、新しいリビジョンが増えるだけだと思います。</p>

<h2 id="couch-db-updater-flush-trees-3">couch_db_updater:flush_trees/3</h2>

<p><code>couch_db_updater:update_docs_int/5</code>に戻ります。次に実行されるのは<code>couch_db_updater:update_local_docs/2</code>ですが、この関数は<code>rev_tree</code>は関係しないので、後まわしにして先に<code>couch_db_updater:flush_trees/3</code>を見てみます。</p>

<p>couch_db_updater.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>flush_trees<span class="o">(</span>_Db, <span class="o">[]</span>, AccFlushedTrees<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    <span class="o">{</span>ok, lists:reverse<span class="o">(</span>AccFlushedTrees<span class="o">)}</span><span class="p">;</span>
<span class="ln"> 3</span>flush_trees<span class="o">(</span><span class="c1">#db{updater_fd = Fd} = Db,
</span><span class="ln"> 4</span><span class="c1"></span>        <span class="o">[</span>InfoUnflushed <span class="p">|</span> RestUnflushed<span class="o">]</span>, AccFlushed<span class="o">)</span> -&gt;
<span class="ln"> 5</span>    <span class="c1">#full_doc_info{update_seq=UpdateSeq, rev_tree=Unflushed} = InfoUnflushed,
</span><span class="ln"> 6</span><span class="c1"></span>    <span class="o">{</span>Flushed, LeafsSize<span class="o">}</span> <span class="o">=</span> couch_key_tree:mapfold<span class="o">(</span>
<span class="ln"> 7</span>        fun<span class="o">(</span>_Rev, Value, Type, Acc<span class="o">)</span> -&gt;
<span class="ln"> 8</span>            <span class="k">case</span> Value of
<span class="ln"> 9</span>            <span class="c1">#doc{deleted = IsDeleted, body = {summary, Summary, AttsFd}} -&gt;
</span><span class="ln">10</span><span class="c1"></span>                % this node value is actually an unwritten document summary,
<span class="ln">11</span>                % write to disk.
<span class="ln">12</span>                % make sure the Fd in the written bins is the same Fd we are
<span class="ln">13</span>                % and convert bins, removing the FD.
<span class="ln">14</span>                % All bins should have been written to disk already.
<span class="ln">15</span>                <span class="k">case</span> <span class="o">{</span>AttsFd, Fd<span class="o">}</span> of
<span class="ln">16</span>                <span class="o">{</span>nil, _<span class="o">}</span> -&gt;
<span class="ln">17</span>                    ok<span class="p">;</span>
<span class="ln">18</span>                <span class="o">{</span>SameFd, SameFd<span class="o">}</span> -&gt;
<span class="ln">19</span>                    ok<span class="p">;</span>
<span class="ln">20</span>                _ -&gt;
<span class="ln">21</span>                    % Fd where the attachments were written to is not the same
<span class="ln">22</span>                    % as our Fd. This can happen when a database is being
<span class="ln">23</span>                    % switched out during a compaction.
<span class="ln">24</span>                    ?LOG_DEBUG<span class="o">(</span><span class="s2">&#34;File where the attachments are written has&#34;</span>
<span class="ln">25</span>                            <span class="s2">&#34; changed. Possibly retrying.&#34;</span>, <span class="o">[])</span>,
<span class="ln">26</span>                    throw<span class="o">(</span>retry<span class="o">)</span>
<span class="ln">27</span>                end,
<span class="ln">28</span>                <span class="o">{</span>ok, NewSummaryPointer, SummarySize<span class="o">}</span> <span class="o">=</span>
<span class="ln">29</span>                    couch_file:append_raw_chunk<span class="o">(</span>Fd, Summary<span class="o">)</span>,
<span class="ln">30</span>                <span class="nv">TotalSize</span> <span class="o">=</span> lists:foldl<span class="o">(</span>
<span class="ln">31</span>                    fun<span class="o">(</span><span class="c1">#att{att_len = L}, A) -&gt; A + L end,
</span><span class="ln">32</span><span class="c1"></span>                    SummarySize, Value#doc.atts<span class="o">)</span>,
<span class="ln">33</span>                <span class="nv">NewValue</span> <span class="o">=</span> <span class="o">{</span>IsDeleted, NewSummaryPointer, UpdateSeq, TotalSize<span class="o">}</span>,
<span class="ln">34</span>                <span class="k">case</span> Type of
<span class="ln">35</span>                leaf -&gt;
<span class="ln">36</span>                    <span class="o">{</span>NewValue, Acc + TotalSize<span class="o">}</span><span class="p">;</span>
<span class="ln">37</span>                branch -&gt;
<span class="ln">38</span>                    <span class="o">{</span>NewValue, Acc<span class="o">}</span>
<span class="ln">39</span>                end<span class="p">;</span>
<span class="ln">40</span>             <span class="o">{</span>_, _, _, LeafSize<span class="o">}</span> when <span class="nv">Type</span> <span class="o">=</span>:<span class="o">=</span> leaf, <span class="nv">LeafSize</span> <span class="o">=</span>/<span class="o">=</span> nil -&gt;
<span class="ln">41</span>                <span class="o">{</span>Value, Acc + LeafSize<span class="o">}</span><span class="p">;</span>
<span class="ln">42</span>             _ -&gt;
<span class="ln">43</span>                <span class="o">{</span>Value, Acc<span class="o">}</span>
<span class="ln">44</span>            end
<span class="ln">45</span>        end, <span class="m">0</span>, Unflushed<span class="o">)</span>,
<span class="ln">46</span>    <span class="nv">InfoFlushed</span> <span class="o">=</span> InfoUnflushed#full_doc_info<span class="o">{</span>
<span class="ln">47</span>        <span class="nv">rev_tree</span> <span class="o">=</span> Flushed,
<span class="ln">48</span>        <span class="nv">leafs_size</span> <span class="o">=</span> LeafsSize
<span class="ln">49</span>    <span class="o">}</span>,
<span class="ln">50</span>    flush_trees<span class="o">(</span>Db, RestUnflushed, <span class="o">[</span>InfoFlushed <span class="p">|</span> AccFlushed<span class="o">])</span>.</code></pre></div></p>

<p><code>#full_doc_info.rev_tree</code>を<code>couch_key_tree/3</code>でまわしていきます。このループの中で<code>#doc.body</code>の<code>Summary</code>をファイルに書き出していき、そのファイルポインタを<code>#doc</code>の代わりに<code>Value</code>として設定します。つまりこの関数では<code>#doc.body</code>をファイルに書き出していることになります。</p>

<h2 id="couch-db-updater-new-index-entries-4">couch_db_updater:new_index_entries/4</h2>

<p><code>couch_db_updater:update_docs_int/5</code>に戻ります。次に実行されるのは<code>couch_db_updater:new_index_entries/4</code>なので、この関数を見てみます。</p>

<p>couch_db_updater.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>new_index_entries<span class="o">([]</span>, AccById, AccBySeq, AccDDocIds<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    <span class="o">{</span>AccById, AccBySeq, AccDDocIds<span class="o">}</span><span class="p">;</span>
<span class="ln"> 3</span>new_index_entries<span class="o">([</span>FullDocInfo<span class="p">|</span>RestInfos<span class="o">]</span>, AccById, AccBySeq, AccDDocIds<span class="o">)</span> -&gt;
<span class="ln"> 4</span>    <span class="c1">#doc_info{revs=[#rev_info{deleted=Deleted}|_], id=Id} = DocInfo =
</span><span class="ln"> 5</span><span class="c1"></span>            couch_doc:to_doc_info<span class="o">(</span>FullDocInfo<span class="o">)</span>,
<span class="ln"> 6</span>    <span class="nv">AccDDocIds2</span> <span class="o">=</span> <span class="k">case</span> Id of
<span class="ln"> 7</span>    &lt;&lt;?DESIGN_DOC_PREFIX, _/binary&gt;&gt; -&gt;
<span class="ln"> 8</span>        <span class="o">[</span>Id <span class="p">|</span> AccDDocIds<span class="o">]</span><span class="p">;</span>
<span class="ln"> 9</span>    _ -&gt;
<span class="ln">10</span>        AccDDocIds
<span class="ln">11</span>    end,
<span class="ln">12</span>    new_index_entries<span class="o">(</span>RestInfos,
<span class="ln">13</span>        <span class="o">[</span>FullDocInfo#full_doc_info<span class="o">{</span><span class="nv">deleted</span><span class="o">=</span>Deleted<span class="o">}</span><span class="p">|</span>AccById<span class="o">]</span>,
<span class="ln">14</span>        <span class="o">[</span>DocInfo<span class="p">|</span>AccBySeq<span class="o">]</span>,
<span class="ln">15</span>        AccDDocIds2<span class="o">)</span>.</code></pre></div></p>

<p>これは<code>#full_doc_info</code>を<code>AccById</code>に、<code>#doc_info</code>を<code>AccBySeq</code>に、DesignDocのIdを<code>AccDDocIds</code>に追加している関数のようです。<code>#doc_info.rev_info</code>の先頭の要素の<code>deleted</code>を<code>#full_doc_info.deleted</code>に設定しているので、削除時はこの契機で<code>#full_doc_info.deleted</code>が設定される、ということになるのかな。</p>

<h2 id="couch-btree-add-remove-3">couch_btree:add_remove/3</h2>

<p><code>couch_db_updater:update_docs_int/5</code>に戻ります。<code>couch_db_updater:new_index_entries/4</code>の戻り値<code>{IndexFullDocInfos, IndexDocInfos, UpdatedDDocIds}</code>を使い、<code>DocInfoByIdBTree</code>、<code>DocInfoBySeqBTree</code>を更新します。</p>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>add_remove<span class="o">(</span>Bt, InsertKeyValues, RemoveKeys<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    <span class="o">{</span>ok, <span class="o">[]</span>, Bt2<span class="o">}</span> <span class="o">=</span> query_modify<span class="o">(</span>Bt, <span class="o">[]</span>, InsertKeyValues, RemoveKeys<span class="o">)</span>,
<span class="ln"> 3</span>    <span class="o">{</span>ok, Bt2<span class="o">}</span>.
<span class="ln"> 4</span>
<span class="ln"> 5</span>query_modify<span class="o">(</span>Bt, LookupKeys, InsertValues, RemoveKeys<span class="o">)</span> -&gt;
<span class="ln"> 6</span>    <span class="c1">#btree{root=Root} = Bt,
</span><span class="ln"> 7</span><span class="c1"></span>    <span class="nv">InsertActions</span> <span class="o">=</span> lists:map<span class="o">(</span>
<span class="ln"> 8</span>        fun<span class="o">(</span>KeyValue<span class="o">)</span> -&gt;
<span class="ln"> 9</span>            <span class="o">{</span>Key, Value<span class="o">}</span> <span class="o">=</span> extract<span class="o">(</span>Bt, KeyValue<span class="o">)</span>,
<span class="ln">10</span>            <span class="o">{</span>insert, Key, Value<span class="o">}</span>
<span class="ln">11</span>        end, InsertValues<span class="o">)</span>,
<span class="ln">12</span>    <span class="nv">RemoveActions</span> <span class="o">=</span> <span class="o">[{</span>remove, Key, nil<span class="o">}</span> <span class="o">||</span> Key &lt;- RemoveKeys<span class="o">]</span>,
<span class="ln">13</span>    <span class="nv">FetchActions</span> <span class="o">=</span> <span class="o">[{</span>fetch, Key, nil<span class="o">}</span> <span class="o">||</span> Key &lt;- LookupKeys<span class="o">]</span>,
<span class="ln">14</span>    <span class="nv">SortFun</span> <span class="o">=</span>
<span class="ln">15</span>        fun<span class="o">({</span>OpA, A, _<span class="o">}</span>, <span class="o">{</span>OpB, B, _<span class="o">})</span> -&gt;
<span class="ln">16</span>            <span class="k">case</span> <span class="nv">A</span> <span class="o">==</span> B of
<span class="ln">17</span>            % A and B are equal, sort by op.
<span class="ln">18</span>            <span class="nb">true</span> -&gt; op_order<span class="o">(</span>OpA<span class="o">)</span> &lt; op_order<span class="o">(</span>OpB<span class="o">)</span><span class="p">;</span>
<span class="ln">19</span>            <span class="nb">false</span> -&gt;
<span class="ln">20</span>                less<span class="o">(</span>Bt, A, B<span class="o">)</span>
<span class="ln">21</span>            end
<span class="ln">22</span>        end,
<span class="ln">23</span>    <span class="nv">Actions</span> <span class="o">=</span> lists:sort<span class="o">(</span>SortFun, lists:append<span class="o">([</span>InsertActions, RemoveActions, FetchActions<span class="o">]))</span>,
<span class="ln">24</span>    <span class="o">{</span>ok, KeyPointers, QueryResults<span class="o">}</span> <span class="o">=</span> modify_node<span class="o">(</span>Bt, Root, Actions, <span class="o">[])</span>,
<span class="ln">25</span>    <span class="o">{</span>ok, NewRoot<span class="o">}</span> <span class="o">=</span> complete_root<span class="o">(</span>Bt, KeyPointers<span class="o">)</span>,
<span class="ln">26</span>    <span class="o">{</span>ok, QueryResults, Bt#btree<span class="o">{</span><span class="nv">root</span><span class="o">=</span>NewRoot<span class="o">}}</span>.</code></pre></div></p>

<p><code>couch_btree:extract/2</code>を呼び出し<code>Key</code>と<code>Value</code>に分けています。このあたりについては<a href="http://masayuki038.github.io/blog/2014/05/30/couchdb-code-reading3/#couchdbupdaterbtreebyidsplit1">以前見た</a>ように、<code>#full_doc_info</code>をディスクに書き込み可能な形式に変換しています。それぞれのActionを準備した後、<code>couch_btree:modify_node/4</code>を呼び出します。</p>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>modify_node<span class="o">(</span>Bt, RootPointerInfo, Actions, QueryOutput<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    <span class="k">case</span> RootPointerInfo of
<span class="ln"> 3</span>    nil -&gt;
<span class="ln"> 4</span>        <span class="nv">NodeType</span> <span class="o">=</span> kv_node,
<span class="ln"> 5</span>        <span class="nv">NodeList</span> <span class="o">=</span> <span class="o">[]</span><span class="p">;</span>
<span class="ln"> 6</span>    _Tuple -&gt;
<span class="ln"> 7</span>        <span class="nv">Pointer</span> <span class="o">=</span> element<span class="o">(</span><span class="m">1</span>, RootPointerInfo<span class="o">)</span>,
<span class="ln"> 8</span>        <span class="o">{</span>NodeType, NodeList<span class="o">}</span> <span class="o">=</span> get_node<span class="o">(</span>Bt, Pointer<span class="o">)</span>
<span class="ln"> 9</span>    end,
<span class="ln">10</span>    <span class="nv">NodeTuple</span> <span class="o">=</span> list_to_tuple<span class="o">(</span>NodeList<span class="o">)</span>,
<span class="ln">11</span>
<span class="ln">12</span>    <span class="o">{</span>ok, NewNodeList, QueryOutput2<span class="o">}</span> <span class="o">=</span>
<span class="ln">13</span>    <span class="k">case</span> NodeType of
<span class="ln">14</span>    kp_node -&gt; modify_kpnode<span class="o">(</span>Bt, NodeTuple, <span class="m">1</span>, Actions, <span class="o">[]</span>, QueryOutput<span class="o">)</span><span class="p">;</span>
<span class="ln">15</span>    kv_node -&gt; modify_kvnode<span class="o">(</span>Bt, NodeTuple, <span class="m">1</span>, Actions, <span class="o">[]</span>, QueryOutput<span class="o">)</span>
<span class="ln">16</span>    end,
<span class="ln">17</span>    <span class="k">case</span> NewNodeList of
<span class="ln">18</span>    <span class="o">[]</span> -&gt;  % no nodes remain
<span class="ln">19</span>        <span class="o">{</span>ok, <span class="o">[]</span>, QueryOutput2<span class="o">}</span><span class="p">;</span>
<span class="ln">20</span>    NodeList -&gt;  % nothing changed
<span class="ln">21</span>        <span class="o">{</span>LastKey, _LastValue<span class="o">}</span> <span class="o">=</span> element<span class="o">(</span>tuple_size<span class="o">(</span>NodeTuple<span class="o">)</span>, NodeTuple<span class="o">)</span>,
<span class="ln">22</span>        <span class="o">{</span>ok, <span class="o">[{</span>LastKey, RootPointerInfo<span class="o">}]</span>, QueryOutput2<span class="o">}</span><span class="p">;</span>
<span class="ln">23</span>    _Else2 -&gt;
<span class="ln">24</span>        <span class="o">{</span>ok, ResultList<span class="o">}</span> <span class="o">=</span> write_node<span class="o">(</span>Bt, NodeType, NewNodeList<span class="o">)</span>,
<span class="ln">25</span>        <span class="o">{</span>ok, ResultList, QueryOutput2<span class="o">}</span>
<span class="ln">26</span>    end.</code></pre></div></p>

<p>更新対象の<code>Tree</code>から<code>NodeType</code>を取り出し、それによって<code>modify_kpnode/6</code>か<code>modify_kvnode/6</code>のどちらかを呼び出します。<code>couch_db_updater:update_docs_int/5</code>からの呼び出しを見ると結局どちらも呼び出されるのですが、<code>modify_kvnode/6</code>の方を見ていきます。</p>

<h2 id="couch-btree-modify-kvnode-6">couch_btree:modify_kvnode/6</h2>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>modify_kvnode<span class="o">(</span>_Bt, NodeTuple, LowerBound, <span class="o">[]</span>, ResultNode, QueryOutput<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    <span class="o">{</span>ok, lists:reverse<span class="o">(</span>ResultNode, bounded_tuple_to_list<span class="o">(</span>NodeTuple, LowerBound, tuple_size<span class="o">(</span>NodeTuple<span class="o">)</span>, <span class="o">[]))</span>, QueryOutput<span class="o">}</span><span class="p">;</span>
<span class="ln"> 3</span>modify_kvnode<span class="o">(</span>Bt, NodeTuple, LowerBound, <span class="o">[{</span>ActionType, ActionKey, ActionValue<span class="o">}</span> <span class="p">|</span> RestActions<span class="o">]</span>, ResultNode, QueryOutput<span class="o">)</span> when LowerBound &gt; tuple_size<span class="o">(</span>NodeTuple<span class="o">)</span> -&gt;
<span class="ln"> 4</span>    <span class="k">case</span> ActionType of
<span class="ln"> 5</span>    insert -&gt;
<span class="ln"> 6</span>        modify_kvnode<span class="o">(</span>Bt, NodeTuple, LowerBound, RestActions, <span class="o">[{</span>ActionKey, ActionValue<span class="o">}</span> <span class="p">|</span> ResultNode<span class="o">]</span>, QueryOutput<span class="o">)</span><span class="p">;</span>
<span class="ln"> 7</span>    remove -&gt;
<span class="ln"> 8</span>        % just drop the action
<span class="ln"> 9</span>        modify_kvnode<span class="o">(</span>Bt, NodeTuple, LowerBound, RestActions, ResultNode, QueryOutput<span class="o">)</span><span class="p">;</span>
<span class="ln">10</span>    fetch -&gt;
<span class="ln">11</span>        % the key/value must not exist in the tree
<span class="ln">12</span>        modify_kvnode<span class="o">(</span>Bt, NodeTuple, LowerBound, RestActions, ResultNode, <span class="o">[{</span>not_found, <span class="o">{</span>ActionKey, nil<span class="o">}}</span> <span class="p">|</span> QueryOutput<span class="o">])</span>
<span class="ln">13</span>    end<span class="p">;</span>
<span class="ln">14</span>modify_kvnode<span class="o">(</span>Bt, NodeTuple, LowerBound, <span class="o">[{</span>ActionType, ActionKey, ActionValue<span class="o">}</span> <span class="p">|</span> RestActions<span class="o">]</span>, AccNode, QueryOutput<span class="o">)</span> -&gt;
<span class="ln">15</span>    <span class="nv">N</span> <span class="o">=</span> find_first_gteq<span class="o">(</span>Bt, NodeTuple, LowerBound, tuple_size<span class="o">(</span>NodeTuple<span class="o">)</span>, ActionKey<span class="o">)</span>,
<span class="ln">16</span>    <span class="o">{</span>Key, Value<span class="o">}</span> <span class="o">=</span> element<span class="o">(</span>N, NodeTuple<span class="o">)</span>,
<span class="ln">17</span>    <span class="nv">ResultNode</span> <span class="o">=</span>  bounded_tuple_to_revlist<span class="o">(</span>NodeTuple, LowerBound, N - <span class="m">1</span>, AccNode<span class="o">)</span>,
<span class="ln">18</span>    <span class="k">case</span> less<span class="o">(</span>Bt, ActionKey, Key<span class="o">)</span> of
<span class="ln">19</span>    <span class="nb">true</span> -&gt;
<span class="ln">20</span>        <span class="k">case</span> ActionType of
<span class="ln">21</span>        insert -&gt;
<span class="ln">22</span>            % ActionKey is less than the Key, so insert
<span class="ln">23</span>            modify_kvnode<span class="o">(</span>Bt, NodeTuple, N, RestActions, <span class="o">[{</span>ActionKey, ActionValue<span class="o">}</span> <span class="p">|</span> ResultNode<span class="o">]</span>, QueryOutput<span class="o">)</span><span class="p">;</span>
<span class="ln">24</span>        remove -&gt;
<span class="ln">25</span>            % ActionKey is less than the Key, just drop the action
<span class="ln">26</span>            modify_kvnode<span class="o">(</span>Bt, NodeTuple, N, RestActions, ResultNode, QueryOutput<span class="o">)</span><span class="p">;</span>
<span class="ln">27</span>        fetch -&gt;
<span class="ln">28</span>            % ActionKey is less than the Key, the key/value must not exist in the tree
<span class="ln">29</span>            modify_kvnode<span class="o">(</span>Bt, NodeTuple, N, RestActions, ResultNode, <span class="o">[{</span>not_found, <span class="o">{</span>ActionKey, nil<span class="o">}}</span> <span class="p">|</span> QueryOutput<span class="o">])</span>
<span class="ln">30</span>        end<span class="p">;</span>
<span class="ln">31</span>    <span class="nb">false</span> -&gt;
<span class="ln">32</span>        % ActionKey and Key are maybe equal.
<span class="ln">33</span>        <span class="k">case</span> less<span class="o">(</span>Bt, Key, ActionKey<span class="o">)</span> of
<span class="ln">34</span>        <span class="nb">false</span> -&gt;
<span class="ln">35</span>            <span class="k">case</span> ActionType of
<span class="ln">36</span>            insert -&gt;
<span class="ln">37</span>                modify_kvnode<span class="o">(</span>Bt, NodeTuple, N+1, RestActions, <span class="o">[{</span>ActionKey, ActionValue<span class="o">}</span> <span class="p">|</span> ResultNode<span class="o">]</span>, QueryOutput<span class="o">)</span><span class="p">;</span>
<span class="ln">38</span>            remove -&gt;
<span class="ln">39</span>                modify_kvnode<span class="o">(</span>Bt, NodeTuple, N+1, RestActions, ResultNode, QueryOutput<span class="o">)</span><span class="p">;</span>
<span class="ln">40</span>            fetch -&gt;
<span class="ln">41</span>                % ActionKey is equal to the Key, insert into the QueryOuput, but re-process the node
<span class="ln">42</span>                % since an identical action key can follow it.
<span class="ln">43</span>                modify_kvnode<span class="o">(</span>Bt, NodeTuple, N, RestActions, ResultNode, <span class="o">[{</span>ok, assemble<span class="o">(</span>Bt, Key, Value<span class="o">)}</span> <span class="p">|</span> QueryOutput<span class="o">])</span>
<span class="ln">44</span>            end<span class="p">;</span>
<span class="ln">45</span>        <span class="nb">true</span> -&gt;
<span class="ln">46</span>            modify_kvnode<span class="o">(</span>Bt, NodeTuple, N + <span class="m">1</span>, <span class="o">[{</span>ActionType, ActionKey, ActionValue<span class="o">}</span> <span class="p">|</span> RestActions<span class="o">]</span>, <span class="o">[{</span>Key, Value<span class="o">}</span> <span class="p">|</span> ResultNode<span class="o">]</span>, QueryOutput<span class="o">)</span>
<span class="ln">47</span>        end
<span class="ln">48</span>    end.</code></pre></div></p>

<p>2番目の<code>when LowerBound &gt; tuple_size(NodeTuple)</code>というガードが付いている方は、現在の<code>FullDocInfo</code>に当該Keyが含まれていない時に呼び出される関数のようです。メインは3番目の関数。最初に呼び出している<code>couch_btree:find_first_gteq/5</code>を見てみます。</p>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>find_first_gteq<span class="o">(</span>_Bt, _Tuple, Start, End, _Key<span class="o">)</span> when <span class="nv">Start</span> <span class="o">==</span> End -&gt;
<span class="ln"> 2</span>    End<span class="p">;</span>
<span class="ln"> 3</span>find_first_gteq<span class="o">(</span>Bt, Tuple, Start, End, Key<span class="o">)</span> -&gt;
<span class="ln"> 4</span>    <span class="nv">Mid</span> <span class="o">=</span> Start + <span class="o">((</span>End - Start<span class="o">)</span> div <span class="m">2</span><span class="o">)</span>,
<span class="ln"> 5</span>    <span class="o">{</span>TupleKey, _<span class="o">}</span> <span class="o">=</span> element<span class="o">(</span>Mid, Tuple<span class="o">)</span>,
<span class="ln"> 6</span>    <span class="k">case</span> less<span class="o">(</span>Bt, TupleKey, Key<span class="o">)</span> of
<span class="ln"> 7</span>    <span class="nb">true</span> -&gt;
<span class="ln"> 8</span>        find_first_gteq<span class="o">(</span>Bt, Tuple, Mid+1, End, Key<span class="o">)</span><span class="p">;</span>
<span class="ln"> 9</span>    <span class="nb">false</span> -&gt;
<span class="ln">10</span>        find_first_gteq<span class="o">(</span>Bt, Tuple, Start, Mid, Key<span class="o">)</span>
<span class="ln">11</span>    end.</code></pre></div></p>

<p><code>Key</code>でバイナリサーチしています。そのまま<code>couch_btree:bounded_tuple_to_revlist/4</code>を見てみます。</p>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln">1</span>bounded_tuple_to_revlist<span class="o">(</span>_Tuple, Start, End, Tail<span class="o">)</span> when Start &gt; End -&gt;
<span class="ln">2</span>    Tail<span class="p">;</span>
<span class="ln">3</span>bounded_tuple_to_revlist<span class="o">(</span>Tuple, Start, End, Tail<span class="o">)</span> -&gt;
<span class="ln">4</span>    bounded_tuple_to_revlist<span class="o">(</span>Tuple, Start+1, End, <span class="o">[</span>element<span class="o">(</span>Start, Tuple<span class="o">)</span><span class="p">|</span>Tail<span class="o">])</span>.</code></pre></div></p>

<p><code>couch_btree:bounded_tuple_to_revlist/4</code>は、<code>couch_btree:find_first_gteq/5</code>を実行して取得した<code>N</code>に対して、<code>LowerBound</code>から<code>N-1</code>までのノードをアキュムレータに追加しています。</p>

<p>その後、<code>ActionKey</code>を<code>N</code>番目の<code>Key</code>と比較します。その結果によって次の操作を<code>N</code>か<code>N+1</code>のどちらかから始めるかを決めています。そして、<code>ActionType</code>が<code>insert</code>ならアキュムレータ<code>ResultNode</code>に追加、<code>delete</code>であれば追加せず、<code>fetch</code>であれば<code>QueryOutput</code>の方に追加します。</p>

<p>最終的に<code>couch_btree:modify_kvnode/6</code>の番目の関数が呼び出されます。ここで、<code>couch_btree:bounded_tuple_to_list/4</code>を呼び出して<code>NodeTuple</code>のうち走査しなかった残りの部分を取得し、<code>ResultNode</code>をreverseしたリストと連結して返します。つまり、この関数の中でkvnodeのリストに対して<code>Actions</code>に入っている操作を適用し、リストを再構成しています。<code>ActionType</code>が<code>delete</code>の時にアキュムレータに追加していないのは、追加しないことによって再構成後のリストにエントリが含まれなくなり、消去されたことになります。また、<code>insert</code>の時の<code>ActionKey</code>が<code>NodeTuple</code>の<code>Key</code>と完全に一致する場合、<code>NodeTuple</code>側のエントリはアキュムレータに追加されず、<code>{ActionKey, ActionValue}</code>が追加される為、既存のエントリは再構成後のエントリに含まれず、結果新しい値で上書きしたようになります。</p>

<h2 id="couch-btree-modify-kpnode-6">couch_btree:modify_kpnode/6</h2>

<p>次に<code>couch_btree:modify_kpnode/6</code>を見てみます。</p>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>modify_kpnode<span class="o">(</span>Bt, <span class="o">{}</span>, _LowerBound, Actions, <span class="o">[]</span>, QueryOutput<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    modify_node<span class="o">(</span>Bt, nil, Actions, QueryOutput<span class="o">)</span><span class="p">;</span>
<span class="ln"> 3</span>modify_kpnode<span class="o">(</span>_Bt, NodeTuple, LowerBound, <span class="o">[]</span>, ResultNode, QueryOutput<span class="o">)</span> -&gt;
<span class="ln"> 4</span>    <span class="o">{</span>ok, lists:reverse<span class="o">(</span>ResultNode, bounded_tuple_to_list<span class="o">(</span>NodeTuple, LowerBound,
<span class="ln"> 5</span>            tuple_size<span class="o">(</span>NodeTuple<span class="o">)</span>, <span class="o">[]))</span>, QueryOutput<span class="o">}</span><span class="p">;</span>
<span class="ln"> 6</span>modify_kpnode<span class="o">(</span>Bt, NodeTuple, LowerBound,
<span class="ln"> 7</span>        <span class="o">[{</span>_, FirstActionKey, _<span class="o">}</span><span class="p">|</span>_<span class="o">]=</span>Actions, ResultNode, QueryOutput<span class="o">)</span> -&gt;
<span class="ln"> 8</span>    <span class="nv">Sz</span> <span class="o">=</span> tuple_size<span class="o">(</span>NodeTuple<span class="o">)</span>,
<span class="ln"> 9</span>    <span class="nv">N</span> <span class="o">=</span> find_first_gteq<span class="o">(</span>Bt, NodeTuple, LowerBound, Sz, FirstActionKey<span class="o">)</span>,
<span class="ln">10</span>    <span class="k">case</span> <span class="nv">N</span> <span class="o">=</span>:<span class="o">=</span> Sz of
<span class="ln">11</span>    <span class="nb">true</span>  -&gt;
<span class="ln">12</span>        % perform remaining actions on last node
<span class="ln">13</span>        <span class="o">{</span>_, PointerInfo<span class="o">}</span> <span class="o">=</span> element<span class="o">(</span>Sz, NodeTuple<span class="o">)</span>,
<span class="ln">14</span>        <span class="o">{</span>ok, ChildKPs, QueryOutput2<span class="o">}</span> <span class="o">=</span>
<span class="ln">15</span>            modify_node<span class="o">(</span>Bt, PointerInfo, Actions, QueryOutput<span class="o">)</span>,
<span class="ln">16</span>        <span class="nv">NodeList</span> <span class="o">=</span> lists:reverse<span class="o">(</span>ResultNode, bounded_tuple_to_list<span class="o">(</span>NodeTuple, LowerBound,
<span class="ln">17</span>            Sz - <span class="m">1</span>, ChildKPs<span class="o">))</span>,
<span class="ln">18</span>        <span class="o">{</span>ok, NodeList, QueryOutput2<span class="o">}</span><span class="p">;</span>
<span class="ln">19</span>    <span class="nb">false</span> -&gt;
<span class="ln">20</span>        <span class="o">{</span>NodeKey, PointerInfo<span class="o">}</span> <span class="o">=</span> element<span class="o">(</span>N, NodeTuple<span class="o">)</span>,
<span class="ln">21</span>        <span class="nv">SplitFun</span> <span class="o">=</span> fun<span class="o">({</span>_ActionType, ActionKey, _ActionValue<span class="o">})</span> -&gt;
<span class="ln">22</span>                not less<span class="o">(</span>Bt, NodeKey, ActionKey<span class="o">)</span>
<span class="ln">23</span>            end,
<span class="ln">24</span>        <span class="o">{</span>LessEqQueries, GreaterQueries<span class="o">}</span> <span class="o">=</span> lists:splitwith<span class="o">(</span>SplitFun, Actions<span class="o">)</span>,
<span class="ln">25</span>        <span class="o">{</span>ok, ChildKPs, QueryOutput2<span class="o">}</span> <span class="o">=</span>
<span class="ln">26</span>                modify_node<span class="o">(</span>Bt, PointerInfo, LessEqQueries, QueryOutput<span class="o">)</span>,
<span class="ln">27</span>        <span class="nv">ResultNode2</span> <span class="o">=</span> lists:reverse<span class="o">(</span>ChildKPs, bounded_tuple_to_revlist<span class="o">(</span>NodeTuple,
<span class="ln">28</span>                LowerBound, N - <span class="m">1</span>, ResultNode<span class="o">))</span>,
<span class="ln">29</span>        modify_kpnode<span class="o">(</span>Bt, NodeTuple, N+1, GreaterQueries, ResultNode2, QueryOutput2<span class="o">)</span>
<span class="ln">30</span>    end.</code></pre></div></p>

<p>3番目の関数を見ていくと、まず<code>NodeTuple</code>のサイズと<code>couch_btree:find_first_gteq/5</code>の結果を比較しています。値が一致する場合は、残りの<code>Actions</code>を指定して<code>couch_btree:modify_node/4</code>を呼び出し、その結果をアキュムレータに加えて返しています。値が一致しない場合は、<code>couch_btree:find_first_gteq/5</code>の結果で返ってきたインデックスを使って<code>NodeTuple</code>からタプルを取り出し、その<code>Key</code>を境として<code>Actions</code>を2つに分割します。<code>Key</code>以下の<code>ActionKey</code>を持つ<code>Actions</code>を指定して<code>couch_btree:modify_node/4</code>を呼び出し、その結果をアキュムレータに加えて、<code>Key</code>より大きい<code>ActionKey</code>を持つ<code>Actions</code>を指定して<code>couch_btree:modify_kpnode/6</code>が呼び出されます。</p>

<p>正直きちんと理解できていないのですが、この関数で<code>couch_btree:modify_node/4</code>を呼び出すと、恐らくそのその先で<code>NodeType</code>が<code>kv_node</code>に変わり、<code>couch_btree:modify_kvnode/4</code>が呼び出され、前記のように更新後のリストが取れるようになるのだと思います。</p>

<h2 id="couch-btree-write-node-3">couch_btree:write_node/3</h2>

<p><code>couch_btree:modify_node/4</code>に戻り、<code>couch_btree:write_node/3</code>を見てみます。</p>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>write_node<span class="o">(</span><span class="c1">#btree{fd = Fd, compression = Comp} = Bt, NodeType, NodeList) -&gt;
</span><span class="ln"> 2</span><span class="c1"></span>    % split up nodes into smaller sizes
<span class="ln"> 3</span>    <span class="nv">NodeListList</span> <span class="o">=</span> chunkify<span class="o">(</span>NodeList<span class="o">)</span>,
<span class="ln"> 4</span>    % now write out each chunk and <span class="k">return</span> the KeyPointer pairs <span class="k">for</span> those nodes
<span class="ln"> 5</span>    <span class="nv">ResultList</span> <span class="o">=</span> <span class="o">[</span>
<span class="ln"> 6</span>        begin
<span class="ln"> 7</span>            <span class="o">{</span>ok, Pointer, Size<span class="o">}</span> <span class="o">=</span> couch_file:append_term<span class="o">(</span>
<span class="ln"> 8</span>                Fd, <span class="o">{</span>NodeType, ANodeList<span class="o">}</span>, <span class="o">[{</span>compression, Comp<span class="o">}])</span>,
<span class="ln"> 9</span>            <span class="o">{</span>LastKey, _<span class="o">}</span> <span class="o">=</span> lists:last<span class="o">(</span>ANodeList<span class="o">)</span>,
<span class="ln">10</span>            <span class="nv">SubTreeSize</span> <span class="o">=</span> reduce_tree_size<span class="o">(</span>NodeType, Size, ANodeList<span class="o">)</span>,
<span class="ln">11</span>            <span class="o">{</span>LastKey, <span class="o">{</span>Pointer, reduce_node<span class="o">(</span>Bt, NodeType, ANodeList<span class="o">)</span>, SubTreeSize<span class="o">}}</span>
<span class="ln">12</span>        end
<span class="ln">13</span>    <span class="o">||</span>
<span class="ln">14</span>        ANodeList &lt;- NodeListList
<span class="ln">15</span>    <span class="o">]</span>,
<span class="ln">16</span>    <span class="o">{</span>ok, ResultList<span class="o">}</span>.</code></pre></div></p>

<p><code>couch_btree:chunkify/1</code>で<code>NodeList</code>を分割し、その後に分割した単位でデータベースファイルに追記(<code>couch_file:append_term/3</code>)しています。<code>couch_btree:chunkify/1</code>を見てみます。</p>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>chunkify<span class="o">(</span>InList<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    <span class="k">case</span> ?term_size<span class="o">(</span>InList<span class="o">)</span> of
<span class="ln"> 3</span>    Size when Size &gt; ?CHUNK_THRESHOLD -&gt;
<span class="ln"> 4</span>        <span class="nv">NumberOfChunksLikely</span> <span class="o">=</span> <span class="o">((</span>Size div ?CHUNK_THRESHOLD<span class="o">)</span> + <span class="m">1</span><span class="o">)</span>,
<span class="ln"> 5</span>        <span class="nv">ChunkThreshold</span> <span class="o">=</span> Size div NumberOfChunksLikely,
<span class="ln"> 6</span>        chunkify<span class="o">(</span>InList, ChunkThreshold, <span class="o">[]</span>, <span class="m">0</span>, <span class="o">[])</span><span class="p">;</span>
<span class="ln"> 7</span>    _Else -&gt;
<span class="ln"> 8</span>        <span class="o">[</span>InList<span class="o">]</span>
<span class="ln"> 9</span>    end.
<span class="ln">10</span>
<span class="ln">11</span>chunkify<span class="o">([]</span>, _ChunkThreshold, <span class="o">[]</span>, <span class="m">0</span>, OutputChunks<span class="o">)</span> -&gt;
<span class="ln">12</span>    lists:reverse<span class="o">(</span>OutputChunks<span class="o">)</span><span class="p">;</span>
<span class="ln">13</span>chunkify<span class="o">([]</span>, _ChunkThreshold, OutList, _OutListSize, OutputChunks<span class="o">)</span> -&gt;
<span class="ln">14</span>    lists:reverse<span class="o">([</span>lists:reverse<span class="o">(</span>OutList<span class="o">)</span> <span class="p">|</span> OutputChunks<span class="o">])</span><span class="p">;</span>
<span class="ln">15</span>chunkify<span class="o">([</span>InElement <span class="p">|</span> RestInList<span class="o">]</span>, ChunkThreshold, OutList, OutListSize, OutputChunks<span class="o">)</span> -&gt;
<span class="ln">16</span>    <span class="k">case</span> ?term_size<span class="o">(</span>InElement<span class="o">)</span> of
<span class="ln">17</span>    Size when <span class="o">(</span>Size + OutListSize<span class="o">)</span> &gt; ChunkThreshold andalso OutList /<span class="o">=</span> <span class="o">[]</span> -&gt;
<span class="ln">18</span>        chunkify<span class="o">(</span>RestInList, ChunkThreshold, <span class="o">[]</span>, <span class="m">0</span>, <span class="o">[</span>lists:reverse<span class="o">([</span>InElement <span class="p">|</span> OutList<span class="o">])</span> <span class="p">|</span> OutputChunks<span class="o">])</span><span class="p">;</span>
<span class="ln">19</span>    Size -&gt;
<span class="ln">20</span>        chunkify<span class="o">(</span>RestInList, ChunkThreshold, <span class="o">[</span>InElement <span class="p">|</span> OutList<span class="o">]</span>, OutListSize + Size, OutputChunks<span class="o">)</span>
<span class="ln">21</span>    end.</code></pre></div></p>

<p><code>InList</code>のサイズを<code>?CHUNK_THRESHOLD</code>(1279)と比較しています。いくつに分割するべきか(<code>NumberOfChunksLikely</code>)を求め、<code>InList</code>のサイズから分割後の各リストに含まれる要素数を求め、分割していきます。</p>

<p>データベースファイルに追加した後、分割されたリスト内のの最後の<code>Key</code>を取得します。そして<code>reduce_tree_size/3</code>を呼び出し、<code>SubTreeSize</code>を求めます。<code>couch_btree:reduce_tree_size/3</code>を見てみます。</p>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>reduce_tree_size<span class="o">(</span>kv_node, NodeSize, _KvList<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    NodeSize<span class="p">;</span>
<span class="ln"> 3</span>reduce_tree_size<span class="o">(</span>kp_node, NodeSize, <span class="o">[])</span> -&gt;
<span class="ln"> 4</span>    NodeSize<span class="p">;</span>
<span class="ln"> 5</span>reduce_tree_size<span class="o">(</span>kp_node, _NodeSize, <span class="o">[{</span>_K, <span class="o">{</span>_P, _Red<span class="o">}}</span> <span class="p">|</span> _<span class="o">])</span> -&gt;
<span class="ln"> 6</span>    % pre <span class="m">1</span>.2 format
<span class="ln"> 7</span>    nil<span class="p">;</span>
<span class="ln"> 8</span>reduce_tree_size<span class="o">(</span>kp_node, _NodeSize, <span class="o">[{</span>_K, <span class="o">{</span>_P, _Red, nil<span class="o">}}</span> <span class="p">|</span> _<span class="o">])</span> -&gt;
<span class="ln"> 9</span>    nil<span class="p">;</span>
<span class="ln">10</span>reduce_tree_size<span class="o">(</span>kp_node, NodeSize, <span class="o">[{</span>_K, <span class="o">{</span>_P, _Red, Sz<span class="o">}}</span> <span class="p">|</span> NodeList<span class="o">])</span> -&gt;
<span class="ln">11</span>    reduce_tree_size<span class="o">(</span>kp_node, NodeSize + Sz, NodeList<span class="o">)</span>.</code></pre></div></p>

<p><code>NodeType</code>によって処理が分かれています。<code>kv_node</code>の場合は<code>NodeSize</code>が返るだけです。<code>kp_node</code>の場合は、<code>NodeList</code>の各要素に含まれる<code>TreeSize</code>を<code>NodeSize</code>に加えています。</p>

<p>続けて<code>couch_btree:reduce_node/3</code>を見てみます。</p>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln">1</span>reduce_node<span class="o">(</span><span class="c1">#btree{reduce=nil}, _NodeType, _NodeList) -&gt;
</span><span class="ln">2</span><span class="c1"></span>    <span class="o">[]</span><span class="p">;</span>
<span class="ln">3</span>reduce_node<span class="o">(</span><span class="c1">#btree{reduce=R}, kp_node, NodeList) -&gt;
</span><span class="ln">4</span><span class="c1"></span>    R<span class="o">(</span>rereduce, <span class="o">[</span>element<span class="o">(</span><span class="m">2</span>, Node<span class="o">)</span> <span class="o">||</span> <span class="o">{</span>_K, Node<span class="o">}</span> &lt;- NodeList<span class="o">])</span><span class="p">;</span>
<span class="ln">5</span>reduce_node<span class="o">(</span><span class="c1">#btree{reduce=R}=Bt, kv_node, NodeList) -&gt;
</span><span class="ln">6</span><span class="c1"></span>    R<span class="o">(</span>reduce, <span class="o">[</span>assemble<span class="o">(</span>Bt, K, V<span class="o">)</span> <span class="o">||</span> <span class="o">{</span>K, V<span class="o">}</span> &lt;- NodeList<span class="o">])</span>.</code></pre></div></p>

<p>これも<code>NodeType</code>によって処理が分かれています。Bt#btree.reduceにバインドされている関数に関しては、<code>kp_node</code>、<code>kv_node</code>共に<a href="http://masayuki038.github.io/blog/2014/05/30/couchdb-code-reading3/#couchdbupdaterbtreebyidreduce2">以前見ています</a>のでここでは割愛します。</p>

<p><code>couch_btree:write_node/3</code>を呼び出した結果、以下の値が返ります。</p>

<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln">1</span><span class="o">[</span>ok, <span class="o">[{</span>LastKey, <span class="o">{</span>Pointer, reduce_node<span class="o">(</span>Bt, NodeType, ANodeList<span class="o">)</span>, SubTreeSize<span class="o">}}</span>, ...<span class="o">]]</span>   </code></pre></div>

<h2 id="couch-btree-complete-root-1">couch_btree:complete_root/1</h2>

<p><code>couch_btree:modify_node/4</code>まで一通り見たので、<code>couch_btree:add_remove/3</code>に戻り、<code>couch_btree:complete_root/2</code>を見てみます。</p>

<p>couch_btree.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln">1</span>complete_root<span class="o">(</span>_Bt, <span class="o">[])</span> -&gt;
<span class="ln">2</span>    <span class="o">{</span>ok, nil<span class="o">}</span><span class="p">;</span>
<span class="ln">3</span>complete_root<span class="o">(</span>_Bt, <span class="o">[{</span>_Key, PointerInfo<span class="o">}])</span>-&gt;
<span class="ln">4</span>    <span class="o">{</span>ok, PointerInfo<span class="o">}</span><span class="p">;</span>
<span class="ln">5</span>complete_root<span class="o">(</span>Bt, KPs<span class="o">)</span> -&gt;
<span class="ln">6</span>    <span class="o">{</span>ok, ResultKeyPointers<span class="o">}</span> <span class="o">=</span> write_node<span class="o">(</span>Bt, kp_node, KPs<span class="o">)</span>,
<span class="ln">7</span>    complete_root<span class="o">(</span>Bt, ResultKeyPointers<span class="o">)</span>.</code></pre></div></p>

<p>第二引数の要素数によって処理が違っています。この第二引数のリストの要素数は、<code>couch_btree:write_node/3</code>中で呼び出した<code>couch_btree:chunkify/1</code>によって分割された数になります。つまり複数のリストに分割された場合は3番目の関数が、分割されなかった場合は2番目の関数が呼ばれます。</p>

<p><code>couch_btree:add_remove/3</code>の最後で、この関数の戻り値<code>{ok, PointerInfo}</code>を<code>Bt#btree.root</code>にバインドします。ようやく<code>couch_db_updater:update_docs_int/5</code>に戻り、更新されたそれぞれの<code>#btree</code>を新しいBtreeとします。</p>

<h2 id="couch-db-updater-commit-data-3">couch_db_updater:commit_data/3</h2>

<p><code>couch_db_updater:update_docs_int/5</code>で最後に呼び出していいる、<code>couch_db_updater:commit_data/3</code>を見てみます。</p>

<p>couch_db_updater.erl:
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="ln"> 1</span>commit_data<span class="o">(</span>Db<span class="o">)</span> -&gt;
<span class="ln"> 2</span>    commit_data<span class="o">(</span>Db, <span class="nb">false</span><span class="o">)</span>.
<span class="ln"> 3</span>
<span class="ln"> 4</span>db_to_header<span class="o">(</span>Db, Header<span class="o">)</span> -&gt;
<span class="ln"> 5</span>    Header#db_header<span class="o">{</span>
<span class="ln"> 6</span>        <span class="nv">update_seq</span> <span class="o">=</span> Db#db.update_seq,
<span class="ln"> 7</span>        <span class="nv">docinfo_by_seq_btree_state</span> <span class="o">=</span> couch_btree:get_state<span class="o">(</span>Db#db.docinfo_by_seq_btree<span class="o">)</span>,
<span class="ln"> 8</span>        <span class="nv">fulldocinfo_by_id_btree_state</span> <span class="o">=</span> couch_btree:get_state<span class="o">(</span>Db#db.fulldocinfo_by_id_btree<span class="o">)</span>,
<span class="ln"> 9</span>        <span class="nv">local_docs_btree_state</span> <span class="o">=</span> couch_btree:get_state<span class="o">(</span>Db#db.local_docs_btree<span class="o">)</span>,
<span class="ln">10</span>        <span class="nv">security_ptr</span> <span class="o">=</span> Db#db.security_ptr,
<span class="ln">11</span>        <span class="nv">revs_limit</span> <span class="o">=</span> Db#db.revs_limit<span class="o">}</span>.
<span class="ln">12</span>
<span class="ln">13</span>commit_data<span class="o">(</span><span class="c1">#db{waiting_delayed_commit=nil} = Db, true) -&gt;
</span><span class="ln">14</span><span class="c1"></span>    Db#db<span class="o">{</span><span class="nv">waiting_delayed_commit</span><span class="o">=</span>erlang:send_after<span class="o">(</span><span class="m">1000</span>,self<span class="o">()</span>,delayed_commit<span class="o">)}</span><span class="p">;</span>
<span class="ln">15</span>commit_data<span class="o">(</span>Db, <span class="nb">true</span><span class="o">)</span> -&gt;
<span class="ln">16</span>    Db<span class="p">;</span>
<span class="ln">17</span>commit_data<span class="o">(</span>Db, _<span class="o">)</span> -&gt;
<span class="ln">18</span>    <span class="c1">#db{
</span><span class="ln">19</span><span class="c1"></span>        <span class="nv">updater_fd</span> <span class="o">=</span> Fd,
<span class="ln">20</span>        <span class="nv">filepath</span> <span class="o">=</span> Filepath,
<span class="ln">21</span>        <span class="nv">header</span> <span class="o">=</span> OldHeader,
<span class="ln">22</span>        <span class="nv">fsync_options</span> <span class="o">=</span> FsyncOptions,
<span class="ln">23</span>        <span class="nv">waiting_delayed_commit</span> <span class="o">=</span> Timer
<span class="ln">24</span>    <span class="o">}</span> <span class="o">=</span> Db,
<span class="ln">25</span>    <span class="k">if</span> is_reference<span class="o">(</span>Timer<span class="o">)</span> -&gt; erlang:cancel_timer<span class="o">(</span>Timer<span class="o">)</span><span class="p">;</span> <span class="nb">true</span> -&gt; ok end,
<span class="ln">26</span>    <span class="k">case</span> db_to_header<span class="o">(</span>Db, OldHeader<span class="o">)</span> of
<span class="ln">27</span>    OldHeader -&gt;
<span class="ln">28</span>        Db#db<span class="o">{</span><span class="nv">waiting_delayed_commit</span><span class="o">=</span>nil<span class="o">}</span><span class="p">;</span>
<span class="ln">29</span>    Header -&gt;
<span class="ln">30</span>        <span class="k">case</span> lists:member<span class="o">(</span>before_header, FsyncOptions<span class="o">)</span> of
<span class="ln">31</span>        <span class="nb">true</span> -&gt; <span class="nv">ok</span> <span class="o">=</span> couch_file:sync<span class="o">(</span>Filepath<span class="o">)</span><span class="p">;</span>
<span class="ln">32</span>        _    -&gt; ok
<span class="ln">33</span>        end,
<span class="ln">34</span>
<span class="ln">35</span>        <span class="nv">ok</span> <span class="o">=</span> couch_file:write_header<span class="o">(</span>Fd, Header<span class="o">)</span>,
<span class="ln">36</span>
<span class="ln">37</span>        <span class="k">case</span> lists:member<span class="o">(</span>after_header, FsyncOptions<span class="o">)</span> of
<span class="ln">38</span>        <span class="nb">true</span> -&gt; <span class="nv">ok</span> <span class="o">=</span> couch_file:sync<span class="o">(</span>Filepath<span class="o">)</span><span class="p">;</span>
<span class="ln">39</span>        _    -&gt; ok
<span class="ln">40</span>        end,
<span class="ln">41</span>
<span class="ln">42</span>        Db#db<span class="o">{</span><span class="nv">waiting_delayed_commit</span><span class="o">=</span>nil,
<span class="ln">43</span>            <span class="nv">header</span><span class="o">=</span>Header,
<span class="ln">44</span>            <span class="nv">committed_update_seq</span><span class="o">=</span>Db#db.update_seq<span class="o">}</span>
<span class="ln">45</span>    end.</code></pre></div></p>

<p><code>Db#db.updater_fd</code>のデータファイルに新しいヘッダを書き出し、完了となります。これによって、更新後のデータが見れるようになります。</p>

<h1 id="conclusion">Conclusion</h1>

<p>データ更新処理の残りの部分を見てきました。CouchDBはデータ更新時に、データベースファイルにある既存のデータは書き換えず、追記していくだけになっている、という部分を読むことが、ようやくできました。</p>

<p>本当はこんな風に読んだ際のメモをダラダラと貼り付けることなく、ササっと読んで纏められれば良いのですが、Erlangや関数型言語そのものに慣れていないこともあって、今回はこういう形となりました。</p>

<p>まだ、viewやcompactin、replication等を見ていないので、<code>kp_node</code>の意味などはよく理解できていません。このあたりはまた気になった時に見てみたいと思います。</p>
</article>
    <footer class="post-footer">
      
      <p class="post-copyright">
        This post was published <strong>1751</strong> days ago, content in the post may be inaccurate, even wrong now, please take risk yourself.
      </p>
    </footer>
    
      
    
  </section>
  <footer class="site-footer">
  <p>© 2017-2019 act-act</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank">Nuo</a>.</p>
  
</footer>



<script async src="//cdn.bootcss.com/video.js/6.2.8/alt/video.novtt.min.js"></script>

<script src="/js/bundle.js"></script>




  </body>
</html>
